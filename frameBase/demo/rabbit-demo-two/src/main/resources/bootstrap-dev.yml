sc:
  datasource:
    mysql:
      ip: 192.168.237.129:3306
      username: admin_2023
      password: adminDK_@2023
      db: demo
  env: dev
  nacos:
    server-addr: 192.168.237.129:8848
    namespace: fde895c3-8a36-45ba-af5e-bd7bb32ddc44
    group: SC_GROUP_C
  redis:
    host: 192.168.237.129
    port: 6379
    database: 5
    password: admin55670@redis
  rabbitmq:
    addresses: 192.168.237.129
    port: 5672
    username: qxx
    password: qxx
    #连接到代理时用的虚拟主机
    virtual-host: /
    # 生产者|消费者分组（保持一致）
    group: msg-group
spring:
  cloud:
    nacos:
      config:
        server-addr: ${sc.nacos.server-addr}
        group: ${sc.nacos.group}
        namespace: ${sc.nacos.namespace}
        prefix: sc-auth-config
        file-extension: yaml
        shared-configs:
          - dataId: application.yaml
            group: DEFAULT_GROUP
            refresh: true
          - dataId: mq.yaml
            group: DEFAULT_GROUP
            refresh: true
      discovery:
        server-addr: ${sc.nacos.server-addr}
        group: ${sc.nacos.group}
        namespace: ${sc.nacos.namespace}
    stream:
      binders:
        myRabbit: # 表示定义的名称，用于于binding整合
          type: rabbit #消息组件类型
          inheritEnvironment: true #配置是否继承应用程序本身的环境
          defaultCandidate: true
          environment: #表示定义的名称，用于于binding整合
            spring:
              rabbitmq:
                host: ${sc.rabbitmq.addresses}
                port: ${sc.rabbitmq.port}
                username: ${sc.rabbitmq.username}
                password: ${sc.rabbitmq.password}
                virtual-host: ${sc.rabbitmq.virtual-host}
      bindings:
        msg-channel-output: #输出通道的名称
          destination: a-exchange #输出通道绑定到a-exchange交换机
          group: ${sc.rabbitmq.group} #分组名称，生产端和消费端需要一致
          contentType: application/json # 内容格式
          default-binder: myRabbit # 设置要绑定的消息服务的具体设置
        msg-channel-input: #输入通道名称
          destination: a-exchange
          group: ${sc.rabbitmq.group}
          ontentType: application/json
          default-binder: myRabbit
          consumer:
            #retryTemplateName: #编码方式配置
            # 最多尝试处理几次，默认3
            maxAttempts: 5
            # 重试时初始避退间隔，单位毫秒，默认1000
            backOffInitialInterval: 1000
            # 重试时最大避退间隔，单位毫秒，默认10000
            backOffMaxInterval: 10000
            # 避退乘数，默认2.0
            backOffMultiplier: 2.0
            # 当listen抛出retryableExceptions未列出的异常时，是否要重试
            defaultRetryable: true
            # 异常是否允许重试的map映射
            retryableExceptions:
              java.lang.RuntimeException: true
              java.lang.IllegalStateException: false
      rabbit:
        bindings:
          msg-channel-output:
            producer:
              declareExchange: true #对于通道终点是否声明交换机
              exchangeAutoDelete: false #交换机是否自动删除
              exchangeDurable: true #交换机持久化
              exchangeType: topic #交换机类型
              bindQueue: true #是否声明队列并绑定到目的地交换机
              declareDlx: true #声明死信交换机
              deadLetterExchange: a-dead-exchange #死信交换机名称
              deadLetterExchangeType: topic #死信交换机类型
              autoBindDlq: true #绑定死信队列
              deadLetterQueueName: a-dead-queue.${sc.rabbitmq.group} #死信队列名称
              dlqDeadLetterExchange: a-dead-exchange #如果DLQ被声明，则将DLX分配给该队列 如果该列声明，那么deadLetterExchange也要声明，这个保持一致
              republishToDlq: true #该值为false如果设置了死信队列，消息对原封不动的发送到死信队列，如果为true，则消息对带上错误信息发送至死信队列
              requeueRejected: true #默认false，只能抛AmqpRejectAndDontRequeueException消息才能到死信队列，如果为true，所有错误消息都会抛到死信队列
              ttl: 60000 #对列生存时间ms
              transacted: true #启动事务
          msg-channel-input:
            consumer:
              declareExchange: true #对于通道终点是否声明交换机
              exchangeAutoDelete: false #交换机是否自动删除
              exchangeDurable: true #交换机持久化
              exchangeType: topic #交换机类型
              bindQueue: true #是否声明队列并绑定到目的地交换机
              declareDlx: true #声明死信交换机
              deadLetterExchange: a-dead-exchange #死信交换机名称
              deadLetterExchangeType: topic #死信交换机类型
              autoBindDlq: true #绑定死信队列
              deadLetterQueueName: a-dead-queue.${sc.rabbitmq.group} #死信队列名称
              dlqDeadLetterExchange: a-dead-exchange #如果DLQ被声明，则将DLX分配给该队列 如果该列声明，那么deadLetterExchange也要声明，这个保持一致
              republishToDlq: true #该值为false如果设置了死信队列，消息对原封不动的发送到死信队列，如果为true，则消息对带上错误信息发送至死信队列
              requeueRejected: true #默认false，只能抛AmqpRejectAndDontRequeueException消息才能到死信队列，如果为true，所有错误消息都会抛到死信队列
              ttl: 60000 #对列生存时间ms
              transacted: true #启动事务