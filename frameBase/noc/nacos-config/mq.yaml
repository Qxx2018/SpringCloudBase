spring:
  rabbitmq:
    addresses: ${sc.rabbitmq.addresses}
    port: ${sc.rabbitmq.port}
    username: ${sc.rabbitmq.username}
    password: ${sc.rabbitmq.password}
    #连接到代理时用的虚拟主机
    virtual-host: ${sc.rabbitmq.virtual-host}
    #是否启用发布确认
    publisher-returns: false
    #异步回调
    publisher-confirm-type: correlated
    #心跳时间 s
    requested-heartbeat: 60
    #连接超时 ms 队列属性设置 与 消息进行单独设置 => 以两者之间TTL较小的那个数值为准
    connection-timeout: 300000
    #Template
    template:
      #启用强制信息
      mandatory: true
    #linstener
    listener:
      type: simple
      simple:
        #是否启动时自动启动容器
        auto-startup: true
        #手动设置ack
        #auto：消费者根据程序执行正常或者抛出异常来决定是提交ack或者nack
        #manual: 手动ack，用户必须手动提交ack或者nack
        #none: 没有ack机制
        acknowledge-mode: manual
        concurrency: 3 #消费者最小数量
        max-concurrency: 10 # 消费者最大数量
        prefetch: 1 #一个消费者最多可处理的nack消息（消费者拒绝或处理异常的无法处理的消息）数量，如果有事务的话，必须大于等于transaction数量.
        retry:
          #开启消费重试
          enabled: true
          #重试五次 重试5次失败之后就会移除该消息
          max-attempts: 5
          #重试初始间隔时间ms
          initial-interval: 500
          #重试最大间隔时间ms
          max-interval: 10000
          #间隔时间乘子  间隔时间*乘子=下一次的间隔时间，最大不能超过设置的最大间隔时间
          multiplier: 2
        # 被拒绝的消息(包括重试后的)是否重新入队；默认是true->重新入队  false->不入队（不想丢弃需要死信队列）
        default-requeue-rejected: true